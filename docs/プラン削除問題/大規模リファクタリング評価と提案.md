# 大規模リファクタリング評価と提案

## 現在のアーキテクチャの問題点

### 1. データソースの重複と不整合
- **Firestore**: メインのデータソース（plans, users コレクション）
- **ローカルストレージ**: キャッシュとして使用
- **Zustand Store**: アプリケーション状態管理

**問題**: 3つのデータソースが同期されていない
- プラン削除時にFirestoreから削除してもローカルストレージに残る
- アクティブプランIDがFirestoreとローカルストレージで不一致

### 2. 非同期処理の競合状態
- `usePlanLoad`: プラン読み込み
- `planListStore`: プランリスト管理
- `planStore`: 現在のプラン管理

**問題**: 初期化順序が保証されていない
- planListStoreが空の状態でusePlanLoadが実行される
- listenToPlanの非同期処理が完了する前に次の処理が走る

### 3. エラーハンドリングの不統一
- `planStore.listenToPlan`: エラー時にplanをnullにしない
- `usePlanLoad`: エラー時の処理が曖昧
- コンポーネント側でエラー状態を考慮していない

### 4. 責務の不明確さ
- アクティブプランIDの管理が複数箇所に分散
- プラン読み込みロジックが複数ファイルに分散
- ローカルストレージ操作が直接行われている

## リファクタリング提案

### Phase 1: データフローの統一（必須）

#### 1.1 単一のデータソース原則
```typescript
// src/services/planDataService.ts (新規)
export class PlanDataService {
  private planListUnsubscribe?: Unsubscribe;
  private currentPlanUnsubscribe?: Unsubscribe;

  // プランリストの監視を開始
  async startListening(userId: string) {
    // 1. プランリストを監視
    this.planListUnsubscribe = await this.listenToUserPlans(userId);
    
    // 2. アクティブプランIDを取得
    const activePlanId = await this.getActivePlanId(userId);
    
    // 3. アクティブプランを監視
    if (activePlanId) {
      await this.setCurrentPlan(activePlanId);
    } else {
      // プランリストから最初のプランを選択
      const plans = usePlanListStore.getState().plans;
      if (plans.length > 0) {
        await this.setCurrentPlan(plans[0].id);
      }
    }
  }

  // 現在のプランを設定（単一の責務）
  async setCurrentPlan(planId: string) {
    // 1. 前の監視を停止
    if (this.currentPlanUnsubscribe) {
      this.currentPlanUnsubscribe();
    }

    // 2. 新しいプランを監視
    this.currentPlanUnsubscribe = listenPlan(planId, (plan) => {
      if (plan) {
        usePlanStore.setState({ 
          plan, 
          isLoading: false, 
          error: null 
        });
        // ローカルストレージも更新（キャッシュとして）
        savePlan(plan);
      } else {
        // プランが見つからない場合は明確にnullを設定
        usePlanStore.setState({ 
          plan: null, 
          isLoading: false, 
          error: 'Plan not found' 
        });
      }
    });

    // 3. アクティブプランIDを更新（Firestore + ローカルストレージ）
    await this.updateActivePlanId(planId);
  }

  // プラン削除（統一されたフロー）
  async deletePlan(planId: string) {
    // 1. Firestoreから削除
    await deletePlanFromCloud(planId);
    
    // 2. ローカルストレージから削除
    deletePlan(planId);
    
    // 3. プランリストを更新
    await usePlanListStore.getState().refreshPlans();
    
    // 4. 新しいアクティブプランを選択
    const remainingPlans = usePlanListStore.getState().plans;
    if (remainingPlans.length > 0) {
      await this.setCurrentPlan(remainingPlans[0].id);
    } else {
      // プランがない状態を明確に設定
      usePlanStore.setState({ 
        plan: null, 
        isLoading: false, 
        error: null 
      });
      await this.updateActivePlanId('');
    }
  }
}
```

#### 1.2 初期化フローの明確化
```typescript
// src/hooks/useInitializePlans.ts (新規)
export function useInitializePlans(user: User | null) {
  const [isInitialized, setIsInitialized] = useState(false);
  const planDataService = useRef<PlanDataService>();

  useEffect(() => {
    if (!user || isInitialized) return;

    const initialize = async () => {
      try {
        // 1. サービスインスタンスを作成
        planDataService.current = new PlanDataService();
        
        // 2. プランリストを初期化
        await usePlanListStore.getState().refreshPlans();
        
        // 3. データ監視を開始
        await planDataService.current.startListening(user.uid);
        
        setIsInitialized(true);
      } catch (error) {
        console.error('Failed to initialize plans:', error);
      }
    };

    initialize();

    return () => {
      planDataService.current?.stopListening();
    };
  }, [user, isInitialized]);

  return { isInitialized, planDataService: planDataService.current };
}
```

### Phase 2: コンポーネントの改善（推奨）

#### 2.1 PlanNameDisplayの改善
```typescript
const PlanNameDisplay: React.FC<PlanNameDisplayProps> = ({ activeTab }) => {
  const { plan, isLoading, error } = usePlanStore();
  const [nameModal, setNameModal] = useState(false);
  
  // リスト表示画面では非表示
  if (activeTab === 'list') return null;
  
  // ローディング中
  if (isLoading) {
    return <div className="...">読み込み中...</div>;
  }
  
  // エラー状態
  if (error && !plan) {
    return <div className="...">エラー: {error}</div>;
  }
  
  // プランがない状態（正常）
  if (!plan) {
    return <EmptyPlanDisplay onCreateClick={() => setNameModal(true)} />;
  }
  
  // 通常の表示
  return <ExistingPlanDisplay plan={plan} />;
};
```

### Phase 3: テストとモニタリング（将来）

#### 3.1 状態遷移のテスト
- プラン作成 → 削除 → 再作成のフロー
- 複数デバイスでの同期
- オフライン → オンライン時の同期

#### 3.2 ログとモニタリング
- 重要な状態遷移をログに記録
- エラー発生時の詳細情報を保存

## 実装優先度

### 必須（Phase 1）
1. **PlanDataService**の実装
2. **useInitializePlans**フックの実装
3. 既存コードの移行

**理由**: 現在の問題の根本原因であるデータフローの不整合を解決

### 推奨（Phase 2）
1. コンポーネントのエラーハンドリング改善
2. ローディング状態の明確化

**理由**: ユーザー体験の向上

### 将来（Phase 3）
1. 自動テストの追加
2. モニタリングシステムの構築

**理由**: 長期的な品質保証

## 結論

**大規模リファクタリングは必要です。**

特にPhase 1のデータフロー統一は、現在の問題を根本的に解決するために必須です。これにより：

1. データの一貫性が保証される
2. 非同期処理の競合状態が解消される
3. エラーハンドリングが統一される
4. 今後の機能追加が容易になる

推定作業時間: Phase 1のみで8-12時間