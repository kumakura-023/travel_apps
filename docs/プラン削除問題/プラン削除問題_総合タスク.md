# プラン削除問題 - 総合タスク

## 問題の総括

### 発見された問題

1. **プラン削除後の新規作成バグ**: 修正済みだが新たな問題を引き起こした
2. **PlanNameDisplay非表示問題**: 根本的な解決に至っていない
3. **データソースの不整合**: Firestore、ローカルストレージ、Zustandストアが同期していない

### 根本原因

1. **planStore.listenToPlan**のエラーハンドリング
   - プランが見つからない場合、planをnullに設定しない（72-75行目）
   - 古いplanデータが残り続ける

2. **初期化タイミングの問題**
   - planListStoreの初期化前にusePlanLoadが実行される
   - 非同期処理の競合状態が発生

3. **データ管理の分散**
   - アクティブプランIDの管理が複数箇所に分散
   - ローカルストレージとFirestoreの同期が保証されていない

## 解決方針

### 短期的解決策（応急処置）

#### 1. planStore.tsの修正

```typescript
// 69-76行目を修正
if (plan) {
  set({ plan, isLoading: false, error: null });
} else {
  console.warn("[planStore] Plan not found or permission denied:", planId);
  // planをnullに設定してエラー状態にする
  set({
    plan: null, // ← 重要: nullを明示的に設定
    isLoading: false,
    error: `Plan with ID ${planId} not found or permission denied.`,
  });
}
```

#### 2. 初期化順序の保証

App.tsxまたは上位コンポーネントで：

```typescript
// プランリストの初期化を待ってからusePlanLoadを実行
useEffect(() => {
  if (user && !isInitializing) {
    const initializePlans = async () => {
      // 1. プランリストを先に初期化
      await usePlanListStore.getState().refreshPlans();

      // 2. その後でプランをロード
      // usePlanLoadの処理をここに移動
    };

    initializePlans();
  }
}, [user, isInitializing]);
```

### 長期的解決策（推奨）

#### Phase 1: データフロー統一（8-12時間）

1. **PlanDataService**の実装
   - すべてのプラン操作を統一
   - Firestore ↔ ローカルストレージの同期を保証
   - エラーハンドリングの一元化

2. **useInitializePlans**フックの実装
   - 初期化順序を明確に制御
   - 非同期処理の競合を防止

3. **既存コードの移行**
   - PlanNameEditModal.tsx
   - usePlanLoad.ts
   - planStore.ts

#### Phase 2: UI/UXの改善（4-6時間）

1. **PlanNameDisplay**の改善
   - ローディング状態の表示
   - エラー状態の表示
   - プランなし状態の適切な表示

2. **エラーリカバリー**
   - 自動リトライ機能
   - ユーザーへの適切なフィードバック

## 実装手順

### Step 1: 応急処置の実装（1-2時間）

1. planStore.tsの修正
2. 初期化順序の修正
3. 動作確認とテスト

### Step 2: PlanDataServiceの設計（2-3時間）

1. インターフェース定義
2. 実装計画の作成
3. 既存コードとの統合計画

### Step 3: 段階的な移行（6-8時間）

1. PlanDataServiceの実装
2. 1機能ずつ移行
3. 各段階でのテスト

### Step 4: UI/UXの改善（4-6時間）

1. コンポーネントの改修
2. エラーハンドリングの実装
3. ユーザビリティテスト

## リスクと対策

### リスク

1. **移行中の不整合**: 段階的移行中に新旧のコードが混在
2. **既存機能への影響**: リファクタリングによる予期しない影響
3. **工数超過**: 想定以上の複雑性

### 対策

1. **フィーチャーフラグ**: 新旧の実装を切り替え可能にする
2. **十分なテスト**: 各段階で回帰テストを実施
3. **段階的リリース**: 小さな変更を順次リリース

## 結論

現在の問題は、アーキテクチャレベルの設計問題に起因しています。短期的な応急処置で一時的に解決できますが、根本的な解決には**データフロー統一のリファクタリングが必要**です。

推奨アプローチ：

1. **まず応急処置**を実装して即座の問題を解決
2. **その後、計画的にリファクタリング**を実施

これにより、安定性と保守性の高いシステムを実現できます。
