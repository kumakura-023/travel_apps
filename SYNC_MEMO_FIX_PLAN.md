# メモ同期処理 修正計画書

## 現状の問題点

### 1. メモ編集時の過剰な同期処理
- **問題**: メモを編集する度に300msのデバウンス後に同期処理が実行される
- **影響**: Firebaseの書き込み制限に達し、`resource-exhausted`エラーが発生
- **症状**: 
  - 大量の`[IGNORE] {reason: '自己更新'}`ログ
  - `Write stream exhausted maximum allowed queued writes`エラー
  - スマホでの処理が重くなる

### 2. アーキテクチャの問題

#### 単一責任原則違反
1. **PlaceDetailPanel.tsx**
   - UI表示、状態管理、同期処理の呼び出しが混在
   - `handleMemoChange`関数で直接同期処理を実行

2. **MemoEditor.tsx**
   - デバウンス処理とUI更新が密結合
   - 同期タイミングの制御がコンポーネント内で固定

3. **useAutoSave.ts**
   - 同期処理、状態管理、タイマー管理が混在
   - 340行の巨大なファイル

#### 同期処理の重複
1. メモ変更時: `MemoEditor` → `PlaceDetailPanel` → `useAutoSave` → `SyncManager`
2. 各層でデバウンス処理が存在（300ms + 1000ms）
3. 同一の変更に対して複数の同期がトリガーされる

## 修正方針

### 1. メモ同期の最適化
- メモ編集完了時（フォーカスアウト時）にのみ同期を実行
- 編集中は同期を完全に停止
- 既存のデバウンス機構を活用し、メモ専用の長いデバウンス時間を設定

### 2. 責任の分離

#### MemoEditor
- UIの表示とローカル状態の管理のみ
- 同期タイミングの判断をしない

#### PlaceDetailPanel  
- UI全体の調整のみ
- 同期処理は`useAutoSave`に委譲

#### useAutoSave
- 同期処理のインターフェースを提供
- 操作タイプに応じた同期戦略の選択

#### SyncManager
- 実際の同期処理の実行
- 書き込み頻度制限の管理

### 3. 実装計画

#### フェーズ1: メモ同期の最適化
1. `MemoEditor`から同期処理を削除
2. `onBlur`イベントで同期をトリガー
3. 編集中フラグを追加し、編集中は同期を抑制

#### フェーズ2: デバウンス戦略の改善
1. `SyncManager`でメモ更新専用の長いデバウンス時間を設定（30秒）
2. 操作タイプ別のデバウンス設定を追加

#### フェーズ3: リファクタリング
1. `useAutoSave`を分割
   - `useSyncManager`: 同期処理のみ
   - `useAutoSave`: 自動保存ロジックのみ
2. 同期状態の管理を専用ストアに移動

## 期待される効果

1. **パフォーマンス向上**
   - メモ編集時の同期回数が大幅に削減
   - Firebaseエラーの解消
   - モバイルでの動作改善

2. **保守性向上**
   - 各コンポーネントの責任が明確化
   - テストしやすい構造
   - 今後の機能追加が容易

3. **ユーザー体験向上**
   - メモ編集がスムーズに
   - エラーの削減
   - 同期状態の可視化

## 実装優先順位

1. **緊急対応**（フェーズ1）
   - メモ編集完了時のみ同期するように修正
   - 既存の過剰な同期を抑制

2. **中期対応**（フェーズ2）
   - デバウンス戦略の最適化
   - 操作別の同期設定

3. **長期対応**（フェーズ3）
   - アーキテクチャのリファクタリング
   - 責任の分離と整理